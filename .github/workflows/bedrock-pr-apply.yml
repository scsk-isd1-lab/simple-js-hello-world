name: Bedrock PR Apply

on:
  issue_comment:
    types: [created]

permissions:
  id-token: write
  contents: write
  pull-requests: write

env:
  AWS_REGION: "ap-northeast-1"

jobs:
  apply:
    if: github.event.issue.pull_request && startsWith(github.event.comment.body, '/apply')
    runs-on: ubuntu-latest
    timeout-minutes: 30
    steps:
      - name: Resolve PR context
        id: ctx
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN || env.ACT_GITHUB_TOKEN || 'local-test-token' }}
          script: |
            if (process.env.ACT === 'true') {
              const outputs = {
                number: process.env.ACT_PR_NUMBER || '123',
                head_ref: process.env.ACT_PR_HEAD_REF || 'feature-branch',
                head_sha: process.env.ACT_PR_HEAD_SHA || 'abc123',
                base_ref: process.env.ACT_PR_BASE_REF || 'main',
                url: process.env.ACT_PR_URL || 'https://github.com/test/repo/pull/123',
              };
              for (const [key, value] of Object.entries(outputs)) {
                core.setOutput(key, `${value ?? ''}`);
              }
              return;
            }
            const path = require('path');
            const workspace = process.env.GITHUB_WORKSPACE || process.cwd();
            const actions = require(path.join(workspace, 'scripts/actions/apply_workflow'));
            const { resolvePullRequestContext } = actions;
            await resolvePullRequestContext({ github, context, core });

      - name: Checkout PR head
        if: env.ACT != 'true'
        uses: actions/checkout@v4
        with:
          ref: refs/pull/${{ steps.ctx.outputs.number }}/head
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN || env.ACT_GITHUB_TOKEN || 'local-test-token' }}

      - name: Assume AWS Role using OIDC
        if: env.ACT != 'true'
        uses: aws-actions/configure-aws-credentials@v5.0.0
        with:
          role-to-assume: arn:aws:iam::649844050696:role/isd1-lab-iamrole-github-actions-deploy
          role-session-name: GitHub_to_AWS_via_FederatedOIDC
          aws-region: ${{ env.AWS_REGION }}

      - name: Build prompt file with PR context (Apply)
        if: env.ACT != 'true'
        run: |
          set -euo pipefail
          BASE_REF="${{ steps.ctx.outputs.base_ref }}"
          HEAD_SHA="${{ steps.ctx.outputs.head_sha }}"
          if git rev-parse --verify -q "origin/${BASE_REF}" >/dev/null 2>&1; then
            BASE_SHA=$(git rev-parse "origin/${BASE_REF}")
          else
            BASE_SHA=$(git merge-base "origin/${BASE_REF}" "${HEAD_SHA}" || echo "${HEAD_SHA}")
          fi
          OUT="scripts/prompts/_runtime_pr_apply.md"
          mkdir -p scripts/prompts

          # 1) Instruction preface (APPLY prompt)
          if [ -f scripts/prompts/pr_apply_agent_ja.md ]; then
            cat scripts/prompts/pr_apply_agent_ja.md > "$OUT"
            echo >> "$OUT"
          elif [ -f scripts/prompts/pr_improve_agent_ja.md ]; then
            # 旧版プロンプトを暫定利用
            cat scripts/prompts/pr_improve_agent_ja.md > "$OUT"
            echo >> "$OUT"
          fi

          {
            echo "### 対象リポジトリ情報"
            echo "- 組織/リポジトリ: ${{ github.repository }}"
            echo "- PR番号: ${{ steps.ctx.outputs.number }}"
            echo "- PR URL: ${{ steps.ctx.outputs.url }}"
            echo "- ブランチ: ${{ steps.ctx.outputs.head_ref }} → ${{ steps.ctx.outputs.base_ref }}"
            echo "- HEAD SHA: ${HEAD_SHA}"
            echo
            echo "### 変更ファイル一覧 (js/html)"
            git diff --name-status "${BASE_SHA}" "${HEAD_SHA}" -- '*.js' '*.html' || true
            echo
            echo "### 差分 (unified=0, 上限あり)"
            echo '```diff'
            git diff --unified=0 --no-color "${BASE_SHA}" "${HEAD_SHA}" -- '*.js' '*.html' | head -c 200000
            echo
            echo '```'
            echo
            echo "### 変更ファイル本文抜粋 (各 800 行まで, 最大 20 ファイル)"
            i=0
            for f in $(git diff --name-only --diff-filter=AM "${BASE_SHA}" "${HEAD_SHA}" -- '*.js' '*.html'); do
              i=$((i+1)); [ $i -gt 20 ] && break
              echo
              echo "#### ${f}"
              echo '```'
              git show "${HEAD_SHA}:${f}" | head -n 800 || true
              echo '```'
            done
            echo
            echo "### 実装指示"
            echo "- 以下のレビュー計画（plan-meta）に基づき、指定されたステップのみを実装してください（未指定なら全ステップ）。"
            echo "- 可能なら小さな論理単位で分割し、各パッチに簡潔なコミットメッセージ案を付すこと。"
            echo
            echo "適用モード:"
            echo "- dry-run: ${{ steps.ctx.outputs.dry }}"
            echo "- steps: ${{ steps.ctx.outputs.steps }}"
          } > "$OUT"

          echo "PROMPT_FILE=$OUT" >> "$GITHUB_ENV"

      - name: Build mock prompt for act
        if: env.ACT == 'true'
        run: |
          mkdir -p scripts/prompts
          prompt="${ACT_PROMPT_TEXT:-[ACT mock] PR apply test input}" 
          printf '%s\n' "$prompt" > scripts/prompts/_runtime_pr_apply.md
          echo "PROMPT_FILE=scripts/prompts/_runtime_pr_apply.md" >> "$GITHUB_ENV"

      - name: Upload apply prompt artifact
        if: env.ACT != 'true'
        uses: actions/upload-artifact@v4
        with:
          name: pr-apply-prompt-${{ steps.ctx.outputs.number }}
          path: scripts/prompts/_runtime_pr_apply.md
          if-no-files-found: error
          retention-days: 7

      - name: Locate latest plan-meta
        if: env.ACT != 'true'
        id: plan
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { findLatestPlanMeta } = require('./scripts/actions/apply_workflow');
            await findLatestPlanMeta({
              github,
              context,
              core,
              issueNumber: parseInt('${{ steps.ctx.outputs.number }}', 10),
            });

      - name: Invoke Bedrock Agent via Python SDK (Apply)
        if: env.ACT != 'true'
        id: bedrock
        env:
          DEBUG_BEDROCK: "1"
          SESSION_ID: ${{ steps.plan.outputs.session_id }}
          BEDROCK_CONNECT_TIMEOUT: "10"
          BEDROCK_READ_TIMEOUT: "1800"
          BEDROCK_MAX_ATTEMPTS: "3"
          AGENT_ID: "HG3FHKX9GY"
          AGENT_ALIAS_ID: "Y7IXOPEHZ2"
          PROMPT_FILE: ${{ env.PROMPT_FILE }}
        run: |
          set -euo pipefail
          python3 scripts/bedrock_invoke_agent.py

      - name: Extract patch from response
        if: env.ACT != 'true'
        id: patch
        run: |
          set -euo pipefail
          # 1) 抽出: ```diff … ``` の最初のブロック
          awk 'BEGIN{flag=0} /^```diff/{flag=1; next} /^```/{if(flag){exit} } {if(flag)print}' bedrock_agent_text.txt > patch.diff || true
          # 2) 代替: 言語指定がない ``` … ``` の最初のブロック
          if [ ! -s patch.diff ]; then
            awk 'BEGIN{flag=0} /^```[a-zA-Z]*$/{flag=1; next} /^```[[:space:]]*$/{if(flag){exit} } {if(flag)print}' bedrock_agent_text.txt > patch.diff || true
          fi
          # 3) 正規化: CRLF 除去 + "\\ No newline at end of file" 行削除 + 末尾に改行
          sed -e 's/\r$//' -e '/^\\ No newline at end of file$/d' patch.diff > patch.norm.diff || cp patch.diff patch.norm.diff
          printf '\n' >> patch.norm.diff
          # 4) サニタイズ: パッチ以外の行を削除（説明文などを除去）
          awk '/^(diff --git |index |--- |\+\+\+ |@@ |[+\- ]|\\ No newline at end of file$)/ || /^\s*$/{print}' patch.norm.diff > patch.sanitized.diff || true
          if [ -s patch.sanitized.diff ]; then
            # 見出し行（--- と +++）が少なくとも1組あることを要求
            if grep -qE '^--- ' patch.sanitized.diff && grep -qE '^\+\+\+ ' patch.sanitized.diff; then
              mv patch.sanitized.diff patch.norm.diff
            else
              # 見出しが無い断片は適用不能として扱う
              : > patch.norm.diff
            fi
          fi
          bytes=$(wc -c < patch.norm.diff | tr -d ' ')
          echo "size=$bytes" >> $GITHUB_OUTPUT
          echo "has_patch=$([ "$bytes" -gt 0 ] && echo true || echo false)" >> $GITHUB_OUTPUT

      - name: Apply patch (dry-run or real)
        if: env.ACT != 'true' && steps.patch.outputs.has_patch == 'true'
        id: apply
        run: |
          set -euo pipefail
          echo "--- Patch preview (first 400 lines) ---"
          head -n 400 patch.norm.diff || true
          if [ "${{ steps.ctx.outputs.dry }}" = "true" ]; then
            echo "dry_run=true" >> $GITHUB_OUTPUT
            exit 0
          fi
          # 適用トライ: unidiff-zero → 3-way → GNU patch（dry-run → 本適用）
          if git apply --check --unidiff-zero patch.norm.diff; then
            git apply --index --unidiff-zero --whitespace=fix patch.norm.diff
          else
            echo "primary apply failed -- trying 3-way merge" >&2
            if git apply --check --3way patch.norm.diff; then
              git apply --index --3way --whitespace=fix patch.norm.diff
            else
              echo "3-way merge failed -- trying GNU patch (dry run)" >&2
              if command -v patch >/dev/null 2>&1; then
                if patch --dry-run -p1 < patch.norm.diff; then
                  patch -p1 < patch.norm.diff
                else
                  echo 'patch apply failed at all strategies.' >&2
                  exit 128
                fi
              else
                echo 'patch command not available and git apply strategies failed.' >&2
                exit 128
              fi
            fi
          fi
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add -A
          git commit -m "chore: apply Bedrock patch from /apply"
          git push origin HEAD:${{ steps.ctx.outputs.head_ref }}
          echo "dry_run=false" >> $GITHUB_OUTPUT

      - name: Comment result to PR
        if: env.ACT != 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const hasPatch = '${{ steps.patch.outputs.has_patch }}' === 'true';
            const dry = '${{ steps.apply.outputs.dry_run }}' === 'true';
            let body = '';
            if (!hasPatch) {
              let raw = '';
              try { raw = fs.readFileSync('bedrock_agent_text.txt', 'utf8'); } catch (e) {}
              body = 'パッチが抽出できませんでした。参考出力:\n\n```\n' + (raw.slice(0,60000)) + '\n```';
            } else if (dry) {
              const snippet = fs.readFileSync('patch.norm.diff', 'utf8').slice(0,60000);
              body = 'dry-run のため適用せず、パッチを提示します:\n\n```diff\n' + snippet + '\n```';
            } else {
              body = 'パッチを適用し、PRブランチへ push しました。';
            }
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: Number('${{ steps.ctx.outputs.number }}'),
              body
            });

      - name: Upload patch artifact (for debugging)
        if: env.ACT != 'true' && steps.patch.outputs.has_patch == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: pr-apply-patch-${{ steps.ctx.outputs.number }}
          path: |
            patch.diff
            patch.norm.diff
          if-no-files-found: warn
          retention-days: 7
